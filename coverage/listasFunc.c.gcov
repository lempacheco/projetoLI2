        -:    0:Source:src/listasFunc.c
        -:    0:Graph:coverage/listasFunc.gcno
        -:    0:Data:coverage/listasFunc.gcda
        -:    0:Runs:1
        -:    1:#include "../include/listasFunc.h"
        -:    2:
        -:    3:
        -:    4://TODO: verificar se o elemento já esta na lista, e não adicionar.
        -:    5:
        -:    6:/*
        -:    7: Verifica se se uma determindada posição pertence a lista. 
        -:    8:*/
       85:    9:int posPertence (NodePosicao* lista, int linha, int coluna){
        -:   10:    
      137:   11:    while(lista != NULL) {
       84:   12:        if (lista->p.l == linha && lista->p.c == coluna + 1) {
        -:   13:            return 1; 
        -:   14:        }
        -:   15:
       52:   16:        lista=lista->prox; 
        -:   17:    }
        -:   18:    return 0; 
        -:   19:}
        -:   20:
        -:   21:/*
        -:   22: Verifica se duas listas são iguais. 
        -:   23:*/
        -:   24:
       12:   25:int listasIguais(NodePosicao* a, NodePosicao* b) {
       12:   26:    int cA = 0, cB = 0;
        -:   27:
       12:   28:    NodePosicao* pa = a;
       27:   29:    while (pa != NULL) {
       21:   30:        cA++;
       21:   31:        if (!posPertence(b, pa->p.l , pa->p.c - 1)) return 0;
       15:   32:        pa = pa->prox;
        -:   33:    }
        -:   34:
        -:   35:    NodePosicao* pb = b;
       19:   36:    while (pb != NULL) {
       13:   37:        cB++;
       13:   38:        if (!posPertence(a, pb->p.l, pb->p.c - 1)) return 0;
       13:   39:        pb = pb->prox;
        -:   40:    }
        -:   41:
        6:   42:    return cA == cB;  // 1 se são iguais, 0 se diferentes
        -:   43:}
        -:   44:
        -:   45:/*
        -:   46: Verifica se uma determinada lista pertence a um grupo.  
        -:   47:*/
        -:   48:
       29:   49:int pertenceAoGrupo(NodePosicao* lista, NodeGrupo* grupo) {
       34:   50:    while (grupo != NULL) {
       10:   51:        if (listasIguais(grupo->cabeca, lista)) return 1;
        5:   52:        grupo = grupo->prox;
        -:   53:    }
        -:   54:    return 0;
        -:   55:}
        -:   56:
        -:   57:
        -:   58:/*
        -:   59: Adiciona uma determinada posição na lista. 
        -:   60: Nesta função a posição é adicionada no final da lista.  
        -:   61:*/
       47:   62:NodePosicao* adicionarPos (NodePosicao* lista, int linha, int coluna) {
        -:   63:    
       47:   64:    if (posPertence(lista, linha, coluna) == 1){
        -:   65:        return lista; 
        -:   66:    }
        -:   67:
       46:   68:    NodePosicao* novaPos = malloc(sizeof(NodePosicao));
        -:   69:
       46:   70:    novaPos->p.l = linha; 
       46:   71:    novaPos->p.c = coluna + 1;
       46:   72:    novaPos->prox = NULL; 
        -:   73:
       46:   74:    if (lista == NULL) {
        -:   75:        return novaPos;  
        -:   76:    } 
        -:   77:    
        -:   78:    NodePosicao* atual=lista; 
       18:   79:    while (atual->prox != NULL){
        -:   80:        atual = atual->prox;
        -:   81:    }
        -:   82:
       15:   83:    atual->prox = novaPos; 
        -:   84:
       15:   85:    return lista; 
        -:   86:}
        -:   87:
        -:   88:/*
        -:   89: A função adiciona uma lista a um grupo, caso esta lista já não pertença ao grupo. 
        -:   90: Atribui uma menasagem a cada lista.   
        -:   91:*/
        -:   92:
       14:   93:NodeGrupo* adicionarLista (NodeGrupo* grupo, NodePosicao* lista, int mensagem) {
        -:   94:    
       14:   95:    if (pertenceAoGrupo(lista,grupo)==1) {return grupo;}
        -:   96:    
       13:   97:    NodeGrupo* novoGrupo = malloc(sizeof(NodeGrupo));
       13:   98:    novoGrupo->cabeca = lista;
       13:   99:    novoGrupo->m = mensagem;  
       13:  100:    novoGrupo->prox = NULL; 
        -:  101:
       13:  102:    if (grupo == NULL) return novoGrupo;
        -:  103:
        -:  104:    NodeGrupo* atual = grupo; 
        2:  105:    while (atual->prox != NULL){
        -:  106:        atual = atual->prox;
        -:  107:    }
        -:  108:
        2:  109:    atual->prox = novoGrupo; 
        2:  110:    return grupo; 
        -:  111:}
        -:  112:
        -:  113:/*
        -:  114: Imprime no terminal a cauda de uma lista.  
        -:  115:*/
    #####:  116:void imprimeCauda (NodePosicao* lista) {
    #####:  117:    if (lista == NULL) {
    #####:  118:        printf("  (nenhuma posição)\n");
    #####:  119:        return;
        -:  120:    }
        -:  121:
    #####:  122:    NodePosicao* atual = lista->prox; 
        -:  123:  
    #####:  124:    while (atual != NULL) {
    #####:  125:        printf(" (%c, %d)\n", (atual->p.l) + 'a', atual->p.c); 
    #####:  126:        atual = atual->prox; 
        -:  127:    }
        -:  128:}
        -:  129:
        -:  130:/*
        -:  131: Imprime no terminal a cabeça de uma lista.  
        -:  132:*/
    #####:  133:void imprimeCabeca (NodePosicao* lista){
    #####:  134:    if (lista != NULL)
    #####:  135:        printf(" (%c, %d) ", (lista->p.l) + 'a', lista->p.c); 
    #####:  136:}
        -:  137:    
        -:  138:/*
        -:  139: Imprime no terminal um grupo, ou seja um conjunto de listas.  
        -:  140:*/
    #####:  141:void imprimeGrupos (NodeGrupo* grupo) {
        -:  142:    
    #####:  143:    if (grupo == NULL) {
    #####:  144:        printf("Não houve quaisquer posições inválidas atingidas.\n"); 
        -:  145:    }
        -:  146:
        -:  147:    NodeGrupo* atualGrupo = grupo;
        -:  148:
    #####:  149:    while (atualGrupo != NULL) {
    #####:  150:        if (atualGrupo->m == 0) {
    #####:  151:            printf("A posicão");
    #####:  152:            imprimeCabeca(atualGrupo->cabeca);
    #####:  153:            printf("tem as seguintes posições riscadas na ortogonal:\n");
    #####:  154:            imprimeCauda(atualGrupo->cabeca);
        -:  155:
    #####:  156:        } else if (atualGrupo->m == 1) {
    #####:  157:            printf("As seguintes posições estão brancas duplicadas na mesma linha/coluna:\n");
    #####:  158:            imprimeCabeca(atualGrupo->cabeca);
    #####:  159:            printf("\n"); 
    #####:  160:            imprimeCauda(atualGrupo->cabeca); 
        -:  161:
        -:  162:        } else {
    #####:  163:            printf("Tipo de restrição desconhecido:\n");
        -:  164:        }
        -:  165:
        -:  166:        
    #####:  167:        atualGrupo = atualGrupo->prox;
    #####:  168:        printf("\n");
        -:  169:    }
    #####:  170:}
        -:  171:
       21:  172:void liberaGrupos(NodeGrupo* lista) {
       34:  173:    while (lista != NULL) {
       13:  174:        NodeGrupo* grupoAtual = lista;
       13:  175:        lista = lista->prox;
        -:  176:
        -:  177:        // Corrigido: usar "cabeca" em vez de "lista"
       13:  178:        NodePosicao* pos = grupoAtual->cabeca;
       38:  179:        while (pos != NULL) {
       25:  180:            NodePosicao* tempPos = pos;
       25:  181:            pos = pos->prox;
       25:  182:            free(tempPos);
        -:  183:        }
        -:  184:
       13:  185:        free(grupoAtual);
        -:  186:    }
       21:  187:}
        -:  188:
        9:  189:void liberaListaPos(NodePosicao* lista) {
       30:  190:    while (lista != NULL) {
       21:  191:        NodePosicao* temp = lista;
       21:  192:        lista = lista->prox;
       21:  193:        free(temp);
        -:  194:    }
        9:  195:}
        -:  196:
        -:  197:
