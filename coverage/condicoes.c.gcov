        -:    0:Source:src/condicoes.c
        -:    0:Graph:coverage/condicoes.gcno
        -:    0:Data:coverage/condicoes.gcda
        -:    0:Runs:1
        -:    1:#include <stdlib.h>
        -:    2:#include "../include/condicoes.h"
        -:    3:
        -:    4:
       23:    5:int verifRiscadaOrt(Matriz *m, int J, int I, NodeGrupo** grupo) {
       23:    6:    NodePosicao* lista = NULL;
        -:    7:
       23:    8:    if (J < m->L - 1 && m->matriz[J + 1][I] == '#')
        2:    9:        lista = adicionarPos(lista, J + 1, I);
       23:   10:    if (J > 0 && m->matriz[J - 1][I] == '#')
        2:   11:        lista = adicionarPos(lista, J - 1, I);
       23:   12:    if (I < m->C - 1 && m->matriz[J][I + 1] == '#')
        2:   13:        lista = adicionarPos(lista, J, I + 1);
       23:   14:    if (I > 0 && m->matriz[J][I - 1] == '#')
        3:   15:        lista = adicionarPos(lista, J, I - 1);
        -:   16:
       23:   17:    if (lista != NULL) {
        9:   18:        NodePosicao* novaLista = adicionarPos(NULL, J, I);
        9:   19:        novaLista->prox = lista;
        9:   20:        lista = novaLista;
        -:   21:
        -:   22:        //só verifica se já pertence antes de liberar qualquer coisa
        9:   23:        if (pertenceAoGrupo(lista, *grupo)) {
        2:   24:            liberaListaPos(lista);  
        -:   25:        } else {
        7:   26:            *grupo = adicionarLista(*grupo, lista, 0);
        -:   27:        }
        -:   28:
        9:   29:        return 0;
        -:   30:    }
        -:   31:
        -:   32:    return 1;
        -:   33:}
        -:   34:
       25:   35:int verifBranco(Matriz *m, int J, int I, NodeGrupo** grupo) {
       25:   36:    int r = 1;
        -:   37:
        -:   38:    // verificação na linha
       25:   39:    NodePosicao* listaLinha = NULL;
      173:   40:    for (int j = 0; j < m->L; j++) {
      148:   41:        if (j != J && m->matriz[j][I] == m->matriz[J][I]) {
        3:   42:            listaLinha = adicionarPos(listaLinha, j, I);
        -:   43:        }
        -:   44:    }
        -:   45:
       25:   46:    if (listaLinha != NULL) {
        3:   47:        listaLinha = adicionarPos(listaLinha, J, I);
        -:   48:
        3:   49:        if (pertenceAoGrupo(listaLinha, *grupo)) {
        1:   50:            liberaListaPos(listaLinha);  //só libera depois de verificar
        -:   51:        } else {
        2:   52:            *grupo = adicionarLista(*grupo, listaLinha, 1);
        2:   53:            r = 0;
        -:   54:        }
        -:   55:    }
        -:   56:
        -:   57:    // verificação na coluna
       25:   58:    NodePosicao* listaColuna = NULL;
      177:   59:    for (int i = 0; i < m->C; i++) {
      152:   60:        if (i != I && m->matriz[J][i] == m->matriz[J][I]) {
        1:   61:            listaColuna = adicionarPos(listaColuna, J, i);
        -:   62:        }
        -:   63:    }
        -:   64:
       25:   65:    if (listaColuna != NULL) {
        1:   66:        listaColuna = adicionarPos(listaColuna, J, I);
        -:   67:
        1:   68:        if (pertenceAoGrupo(listaColuna, *grupo)) {
    #####:   69:            liberaListaPos(listaColuna);  
        -:   70:        } else {
        1:   71:            *grupo = adicionarLista(*grupo, listaColuna, 1);
        1:   72:            r = 0;
        -:   73:        }
        -:   74:    }
        -:   75:
       25:   76:    return r;
        -:   77:}
        -:   78:
        -:   79:
        6:   80:int verificar(Matriz *m, NodeGrupo** grupo) {
        6:   81:    int valido = 1;  
        -:   82:    
        -:   83:
        -:   84:    //linha
       43:   85:    for (int j = 0; j < m->L; j++) {
        -:   86:        //coluna
      293:   87:        for (int i = 0; i < m->C; i++) {
      256:   88:            if (isupper(m->matriz[j][i])) {
       18:   89:                if (!verifBranco(m, j, i, grupo)){
        1:   90:                    valido = 0;
        -:   91:                } 
        -:   92:            }
        -:   93:
      256:   94:            if (m->matriz[j][i] == '#') { 
       16:   95:                if (!verifRiscadaOrt(m, j, i,grupo)) {
        4:   96:                    valido = 0;
        -:   97:                }
        -:   98:            }
        -:   99:        }
        -:  100:    }
        -:  101:
        6:  102:    return valido;
        -:  103:}
        -:  104:
        2:  105:int verificaCaminho (Matriz *m, Queue *q){
        2:  106:    int casasVisitadas = 0;
        2:  107:    int casasLivres = 0;  
        2:  108:    Pos temp; 
        -:  109:    
        2:  110:    m->visitada = malloc(sizeof(int*)*m->L); 
       12:  111:    for(int i=0; i<m->L; i++){
       10:  112:        m->visitada[i] = malloc(sizeof(int)*m->C); 
       60:  113:        for(int j=0; j<m->C; j++){
       50:  114:            m->visitada[i][j] = 0; 
        -:  115:        }
        -:  116:    }
        -:  117:
        -:  118:    int encontrada = 0; 
       12:  119:    for (int i = 0; i < m->L; i++) {
       60:  120:        for (int j = 0; j < m->C; j++) {
       50:  121:            if (m->matriz[i][j] != '#') {
       44:  122:                casasLivres++;
       44:  123:                if (!encontrada) {
        2:  124:                    Pos pInicial = {i, j};
        2:  125:                    enqueue(q, pInicial);
        2:  126:                    encontrada = 1;
        -:  127:                }
        -:  128:            }
        -:  129:        }
        -:  130:    }
        -:  131:
      140:  132:    while (!isEmptyQ(q)) {
      138:  133:        dequeue(q, &temp); 
      138:  134:        int i = temp.l; 
      138:  135:        int j = temp.c; 
        -:  136:
      138:  137:        if (i >= 0 && i < m->L && j >= 0 && j < m->C) { 
      138:  138:            if (m->matriz[i][j] != '#' && m->visitada[i][j] == 0) {
       43:  139:                casasVisitadas++; 
       43:  140:                m->visitada[i][j] = 1;
        -:  141:
       43:  142:                Pos p1 = {i + 1 , j};
       43:  143:                Pos p2 = {i, j + 1};
       43:  144:                Pos p3 = {i - 1, j};
       43:  145:                Pos p4 = {i, j - 1};
        -:  146:
       43:  147:                if (i + 1 < m->L) {
       35:  148:                    enqueue(q, p1); 
        -:  149:                }
       43:  150:                if (j + 1 < m->C) {
       35:  151:                    enqueue(q, p2);
        -:  152:                }
       43:  153:                if (i - 1 >= 0) {
       33:  154:                    enqueue(q, p3);
        -:  155:                }
       43:  156:                if (j - 1 >= 0) {
       33:  157:                    enqueue(q, p4);
        -:  158:                }
        -:  159:            }
        -:  160:        }
        -:  161:    }
        -:  162:
       12:  163:    for (int i = 0; i < m->L; i++) {
       10:  164:            free (m->visitada[i]); 
        -:  165:    }
        2:  166:    free(m->visitada); 
        -:  167:
        2:  168:    return (casasVisitadas == casasLivres); 
        -:  169:}
