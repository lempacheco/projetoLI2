        -:    0:Source:src/ajuda.c
        -:    0:Graph:coverage/ajuda.gcno
        -:    0:Data:coverage/ajuda.gcda
        -:    0:Runs:1
        -:    1:#include "../include/ajuda.h"
        -:    2:
    #####:    3:int ajuda(Matriz* m, Queue* q) {
    #####:    4:    NodeGrupo* grupos = NULL;
    #####:    5:    int r;
    #####:    6:    Matriz t;
        -:    7:    
    #####:    8:    initMatriz(&t);
    #####:    9:    copiaMatriz(&t, m);
        -:   10:
    #####:   11:    liberaGrupos(grupos);
    #####:   12:    grupos = NULL;
        -:   13:
    #####:   14:    if (verificar(m, &grupos)) {
    #####:   15:        liberaGrupos(grupos); grupos = NULL;
    #####:   16:        riscarIguaisDeLetraBranca(m, &grupos);
        -:   17:
    #####:   18:        liberaGrupos(grupos); grupos = NULL;
    #####:   19:        pintarVizinhosDeRiscadas(m, &grupos);
        -:   20:
    #####:   21:        liberaGrupos(grupos); grupos = NULL;
    #####:   22:        manterCaminho(m, q, &grupos);
        -:   23:
    #####:   24:        r = 0;
        -:   25:    } else {
    #####:   26:        printf("O tabuleiro atual é inválido.\n");
    #####:   27:        r = -1;
        -:   28:    }
        -:   29:
        -:   30:
    #####:   31:    liberaGrupos(grupos); grupos = NULL;
    #####:   32:    if (!verificar(m, &grupos)) {
    #####:   33:        copiaMatriz(m, &t);
    #####:   34:        printf("O tabuleiro já não é válido");
    #####:   35:        r = -1;
        -:   36:    }
        -:   37:
    #####:   38:    liberaMatriz(&t);
    #####:   39:    liberaGrupos(grupos);
        -:   40:
    #####:   41:    return r;
        -:   42:}
        -:   43:
    #####:   44:void riscarIguaisDeLetraBranca(Matriz* m, NodeGrupo** grupos){
    #####:   45:    for(int i=0; i<m->L; i++){
    #####:   46:        for(int j=0; j<m->C; j++){
    #####:   47:            if (isupper(m->matriz[i][j]) && m->matriz[i][j]!='#'){
    #####:   48:                for(int l=0; l<m->L; l++){
    #####:   49:                    if(tolower(m->matriz[i][j]) == m->matriz[l][j]){
    #####:   50:                        char t = m->matriz[l][j];
    #####:   51:                        m->matriz[l][j] = '#';
    #####:   52:                        if(!verificar(m, grupos)){
    #####:   53:                            m->matriz[l][j] = t;
        -:   54:                        }
        -:   55:                    }
        -:   56:                }
    #####:   57:                for(int c=0; c<m->C; c++){
    #####:   58:                    if(tolower(m->matriz[i][j]) == m->matriz[i][c]){
    #####:   59:                        char t = m->matriz[i][c];
    #####:   60:                        m->matriz[i][c] = '#';
    #####:   61:                        if(!verificar(m, grupos)) m->matriz[i][c] = t;
        -:   62:                    }
        -:   63:                }
        -:   64:            }
        -:   65:        }
        -:   66:    }
    #####:   67:}
        -:   68:
    #####:   69:void pintarVizinhosDeRiscadas(Matriz* m, NodeGrupo** grupos){
    #####:   70:    int i, j;
    #####:   71:    for (i=0; i<m->L; i++){
    #####:   72:        for (j=0; j<m->C; j++){
    #####:   73:            if (m->matriz[i][j]=='#'){
    #####:   74:                if (i+1<m->L){
    #####:   75:                    m->matriz[i+1][j] = toupper(m->matriz[i+1][j]);
    #####:   76:                    if(!verificar(m, grupos)) m->matriz[i+1][j] = tolower(m->matriz[i+1][j]);
        -:   77:                } 
        -:   78:
    #####:   79:                if (i-1>=0){
    #####:   80:                    m->matriz[i-1][j] = toupper(m->matriz[i-1][j]);
    #####:   81:                    if(!verificar(m, grupos)) m->matriz[i-1][j] = tolower(m->matriz[i-1][j]);
        -:   82:                } 
        -:   83:
    #####:   84:                if (j+1<m->C){
    #####:   85:                    m->matriz[i][j+1] = toupper(m->matriz[i][j+1]);
    #####:   86:                    if(!verificar(m, grupos)) m->matriz[i][j+1] = tolower(m->matriz[i][j+1]);
        -:   87:                } 
        -:   88:
    #####:   89:                if (j-1>=0){
    #####:   90:                    m->matriz[i][j-1] = toupper(m->matriz[i][j-1]);
    #####:   91:                    if(!verificar(m, grupos)) m->matriz[i][j-1] = tolower(m->matriz[i][j-1]);
        -:   92:                }
        -:   93:            }   
        -:   94:        }
        -:   95:    }
    #####:   96:}
        -:   97:
    #####:   98:void manterCaminho(Matriz* m, Queue* q, NodeGrupo** grupos){
    #####:   99:    int i, j;
    #####:  100:    char t;
    #####:  101:    for (i=0; i<m->L; i++){
    #####:  102:        for (j=0; j<m->C; j++){
    #####:  103:            t = m->matriz[i][j];
    #####:  104:            m->matriz[i][j] = '#';
    #####:  105:            if (!verificaCaminho(m, q)){
    #####:  106:                m->matriz[i][j] = toupper(t);
        -:  107:            }
    #####:  108:            else if (verificaCaminho(m, q) || !verificar(m, grupos)){
    #####:  109:                m->matriz[i][j] = t;
        -:  110:            }
        -:  111:        }
        -:  112:    }
    #####:  113:}
