        -:    0:Source:src/stackMats.c
        -:    0:Graph:coverage/stackMats.gcno
        -:    0:Data:coverage/stackMats.gcda
        -:    0:Runs:1
        -:    1:#include "../include/stackMats.h"
        -:    2:
       37:    3:void initStackMat(StackMat *s){
       37:    4:    s->tam = 1;
       37:    5:    s->dados = malloc(sizeof(Matriz) * s->tam);
       37:    6:    s->comandos = malloc(sizeof(char) * s->tam);
       37:    7:    initMatriz(&s->dados[0]);
       37:    8:    initMatriz(&s->mInicial);
       37:    9:    s->cabeca = -1;
       37:   10:}
        -:   11:
      245:   12:void initMatriz(Matriz* m){
      245:   13:    m->L = 0;
      245:   14:    m->C = 0;
      245:   15:    m->matriz = NULL;
      245:   16:}
        -:   17:
        2:   18:int isFull(StackMat *s){
        2:   19:    return s->cabeca == s->tam - 1;
        -:   20:}
        -:   21:
        5:   22:int isEmpty(StackMat *s){
        5:   23:    return s->cabeca == -1;  
        -:   24:}
        -:   25:
      154:   26:void liberaMatriz(Matriz *m){
      813:   27:    for (int i = 0; i < m->L; i++) {
      659:   28:        free(m->matriz[i]);
        -:   29:    }
      154:   30:    free(m->matriz); 
      154:   31:    initMatriz(m);
      154:   32:}
        -:   33:
       41:   34:void liberaStackMat(StackMat *s){
       80:   35:    for (int i = 0; i <= s->cabeca; i++) {
       39:   36:        liberaMatriz(&s->dados[i]);
        -:   37:    }
       41:   38:    free(s->dados);
       41:   39:    free(s->comandos);
       41:   40:    s->dados = NULL;
       41:   41:    s->cabeca = -1;
       41:   42:    s->tam = 0;
       41:   43:    liberaMatriz(&s->mInicial);
       41:   44:}
        -:   45:
       13:   46:void push(StackMat *s, Matriz *m, char comando){
       13:   47:    if (s->cabeca + 1 >= s->tam) {
        3:   48:        s->tam++;
        3:   49:        s->dados = realloc(s->dados, sizeof(Matriz) * s->tam);
        3:   50:        s->comandos = realloc(s->comandos, sizeof(char) * s->tam);
        -:   51:    }
        -:   52:
       13:   53:    s->cabeca++;
        -:   54:
       13:   55:    s->comandos[s->cabeca] = comando;
       13:   56:    initMatriz(&s->dados[s->cabeca]);
       13:   57:    copiaMatriz(&s->dados[s->cabeca], m);
       13:   58:}
        -:   59:
        3:   60:int pop(StackMat *s, Matriz* m){
        3:   61:    if (isEmpty(s)) {
        1:   62:        printf("Não há mais comandos para retroceder.");
        1:   63:        return -1;
        -:   64:    }
        -:   65:
        2:   66:    copiaMatriz(m, &(s->dados[s->cabeca]));
        2:   67:    liberaMatriz(&(s->dados[s->cabeca])); 
        2:   68:    s->comandos[s->cabeca] = '\0';
        2:   69:    s->cabeca--;
        2:   70:    return 0;
        -:   71:}
        -:   72:
       28:   73:void copiaMatriz(Matriz *dest, Matriz *src){
        -:   74:
       28:   75:    if (dest->matriz != NULL) liberaMatriz(dest);
       28:   76:    if (src->matriz == NULL) {
        5:   77:        dest->L = 0;
        5:   78:        dest->C = 0;
        5:   79:        dest->matriz = NULL;
        5:   80:        return;
        -:   81:    }
       23:   82:    dest->L = src->L;
       23:   83:    dest->C = src->C;
        -:   84:
       23:   85:    dest->matriz = malloc(sizeof(char*) * src->L);
      163:   86:    for (int i = 0; i < src->L; i++) {
      140:   87:        dest->matriz[i] = malloc(sizeof(char) * src->C);
     1254:   88:        for (int j = 0; j < src->C; j++) {
     1114:   89:            dest->matriz[i][j] = src->matriz[i][j];
        -:   90:        }
        -:   91:    }
        -:   92:}
